import assert from "node:assert/strict";
import test from "node:test";
import type { TestContext } from "node:test";
import { McpStdioHarness } from "../mock/mcp-stdio-harness.js";
import {
  callToolWithRateLimitRetry,
  guardLiveTest,
  isRateLimitedEnvelope,
  readLiveIntegrationEnv,
  requireLiveFixture,
  skipOnLiveRateLimit,
  startLiveWithRetry,
} from "../shared/env.js";

const liveEnv = readLiveIntegrationEnv();

const readVulnerabilityData = (
  envelope: Record<string, unknown>,
): Record<string, unknown> => {
  const data = envelope.data as Record<string, unknown> | undefined;
  if (!data) {
    throw new Error("Vulnerability response did not include data.");
  }
  return data;
};

const readPaginatedData = (
  envelope: Record<string, unknown>,
): Record<string, unknown>[] => {
  const data = envelope.data as
    | { results?: { data?: Record<string, unknown>[] } }
    | undefined;
  return data?.results?.data ?? [];
};

const sleep = async (ms: number): Promise<void> =>
  new Promise(resolve => setTimeout(resolve, ms));

const callLiveTool = async (
  t: TestContext,
  harness: McpStdioHarness,
  toolName: string,
  args: Record<string, unknown>,
): Promise<Record<string, unknown>> => {
  const envelope = await callToolWithRateLimitRetry(harness, toolName, args);
  if (isRateLimitedEnvelope(envelope)) {
    t.skip(`${toolName} was rate-limited after retries.`);
  }
  return envelope;
};

const readEndCursor = (envelope: Record<string, unknown>): string | null => {
  const data = envelope.data as
    | { results?: { pageInfo?: { endCursor?: unknown } } }
    | undefined;
  const cursor = data?.results?.pageInfo?.endCursor;
  if (typeof cursor !== "string" || cursor.length === 0) {
    return null;
  }
  return cursor;
};

const hasNextPage = (envelope: Record<string, unknown>): boolean => {
  const data = envelope.data as
    | { results?: { pageInfo?: { hasNextPage?: unknown } } }
    | undefined;
  return data?.results?.pageInfo?.hasNextPage === true;
};

const waitForDeactivationState = async (
  t: TestContext,
  harness: McpStdioHarness,
  vulnerabilityId: string,
  expectedDeactivated: boolean,
): Promise<Record<string, unknown>> => {
  for (let attempt = 0; attempt < 8; attempt += 1) {
    const envelope = await callLiveTool(t, harness, "get_vulnerability", {
      vulnerabilityId,
    });
    assert.equal(envelope.success, true);
    const data = readVulnerabilityData(envelope);
    const deactivateMetadata = data.deactivateMetadata;
    const isDeactivated =
      deactivateMetadata !== null && deactivateMetadata !== undefined;
    if (isDeactivated === expectedDeactivated) {
      return data;
    }
    await sleep(1_000);
  }

  throw new Error(
    `Timed out waiting for vulnerability ${vulnerabilityId} deactivated=${expectedDeactivated.toString()}.`,
  );
};

const discoverVulnerabilityId = async (
  t: TestContext,
  harness: McpStdioHarness,
): Promise<string | null> => {
  const listedEnvelope = await callLiveTool(
    t,
    harness,
    "list_vulnerabilities",
    {
      pageSize: 25,
      isDeactivated: false,
    },
  );
  if (listedEnvelope.success !== true) {
    return null;
  }
  const candidate = readPaginatedData(listedEnvelope).find(
    item => typeof item.id === "string" && item.id.length > 0,
  );
  const id = candidate?.id;
  if (typeof id !== "string") {
    return null;
  }
  return id;
};

const discoverRemediationId = async (
  t: TestContext,
  harness: McpStdioHarness,
  vulnerabilityId: string,
): Promise<string | null> => {
  let cursor: string | null = null;

  for (let page = 0; page < 25; page += 1) {
    const listedEnvelope = await callLiveTool(
      t,
      harness,
      "list_vulnerability_remediations",
      {
        pageSize: 100,
        ...(cursor ? { pageCursor: cursor } : {}),
      },
    );
    if (listedEnvelope.success !== true) {
      return null;
    }
    const candidate = readPaginatedData(listedEnvelope).find(
      item =>
        item.vulnerabilityId === vulnerabilityId &&
        typeof item.id === "string" &&
        item.id.length > 0,
    );
    const id = candidate?.id;
    if (typeof id === "string") {
      return id;
    }
    if (!hasNextPage(listedEnvelope)) {
      return null;
    }
    cursor = readEndCursor(listedEnvelope);
    if (!cursor) {
      return null;
    }
  }

  return null;
};

test(
  "live integration verifies vulnerability lifecycle writes with readback assertions",
  { timeout: liveEnv.timeoutMs },
  async t => {
    // Arrange
    if (!guardLiveTest(t, liveEnv, true)) {
      return;
    }
    const harness = new McpStdioHarness({ timeoutMs: liveEnv.timeoutMs });
    try {
      await startLiveWithRetry(async () => harness.start());
    } catch (error) {
      if (skipOnLiveRateLimit(t, error, "vulnerability lifecycle write")) {
        return;
      }
      throw error;
    }

    let vulnerabilityId: string | null = liveEnv.vulnerabilityId;
    let remediationId: string | null = liveEnv.remediationId;
    let needsReactivation = false;

    try {
      // Initial Assert
      const tools = await harness.listTools();
      assert.ok(tools.includes("deactivate_vulnerabilities"));
      assert.ok(tools.includes("reactivate_vulnerabilities"));
      assert.ok(tools.includes("get_vulnerability"));

      // Act
      if (!vulnerabilityId) {
        vulnerabilityId = await discoverVulnerabilityId(t, harness);
      }
      if (!vulnerabilityId) {
        vulnerabilityId = requireLiveFixture(
          t,
          liveEnv,
          null,
          "VANTA_INTEGRATION_TEST_VULNERABILITY_ID",
          "No active vulnerability was discovered for lifecycle testing.",
        );
        if (!vulnerabilityId) {
          return;
        }
      }

      const baselineEnvelope = await callLiveTool(
        t,
        harness,
        "get_vulnerability",
        {
          vulnerabilityId,
        },
      );
      assert.equal(baselineEnvelope.success, true);

      const deactivateEnvelope = await callLiveTool(
        t,
        harness,
        "deactivate_vulnerabilities",
        {
          body: {
            updates: [
              {
                id: vulnerabilityId,
                deactivateReason: "Integration lifecycle verification",
                shouldReactivateWhenFixable: false,
              },
            ],
          },
          confirm: true,
        },
      );
      assert.equal(deactivateEnvelope.success, true);
      needsReactivation = true;

      const deactivatedRead = await waitForDeactivationState(
        t,
        harness,
        vulnerabilityId,
        true,
      );
      assert.equal(typeof deactivatedRead.id, "string");

      const reactivateEnvelope = await callLiveTool(
        t,
        harness,
        "reactivate_vulnerabilities",
        {
          body: {
            updates: [{ id: vulnerabilityId }],
          },
          confirm: true,
        },
      );
      assert.equal(reactivateEnvelope.success, true);
      needsReactivation = false;

      const reactivatedRead = await waitForDeactivationState(
        t,
        harness,
        vulnerabilityId,
        false,
      );
      assert.equal(typeof reactivatedRead.id, "string");

      if (!remediationId) {
        remediationId = await discoverRemediationId(
          t,
          harness,
          vulnerabilityId,
        );
      }
      if (!remediationId) {
        remediationId = requireLiveFixture(
          t,
          liveEnv,
          null,
          "VANTA_INTEGRATION_TEST_REMEDIATION_ID",
          "No vulnerability remediation was discovered for SLA acknowledgement verification.",
        );
      }
      if (!remediationId) {
        return;
      }

      const acknowledgeEnvelope = await callLiveTool(
        t,
        harness,
        "acknowledge_sla_miss_vulnerability_remediations",
        {
          body: {
            updates: [
              {
                id: remediationId,
                slaViolationComment: "Integration test acknowledgement comment",
              },
            ],
          },
          confirm: true,
        },
      );
      assert.equal(acknowledgeEnvelope.success, true);

      const remediationReadEnvelope = await callLiveTool(
        t,
        harness,
        "list_vulnerability_remediations",
        {
          pageSize: 100,
        },
      );
      assert.equal(remediationReadEnvelope.success, true);
      const acknowledged = readPaginatedData(remediationReadEnvelope).find(
        item => item.id === remediationId,
      );
      assert.ok(acknowledged);
    } finally {
      if (vulnerabilityId && needsReactivation) {
        try {
          await harness.callTool("reactivate_vulnerabilities", {
            body: {
              updates: [{ id: vulnerabilityId }],
            },
            confirm: true,
          });
        } catch {
          // Best-effort cleanup in live tenant.
        }
      }
      await harness.stop();
    }
  },
);
