import assert from "node:assert/strict";
import test from "node:test";
import { parseToolEnvelope } from "../../helpers.js";
import { McpStdioHarness } from "../mock/mcp-stdio-harness.js";
import {
  guardLiveTest,
  readLiveIntegrationEnv,
  requireLiveFixture,
  skipOnLiveRateLimit,
  startLiveWithRetry,
} from "../shared/env.js";

const liveEnv = readLiveIntegrationEnv();

const readVulnerabilityData = (
  envelope: Record<string, unknown>,
): Record<string, unknown> => {
  const data = envelope.data as Record<string, unknown> | undefined;
  if (!data) {
    throw new Error("Vulnerability response did not include data.");
  }
  return data;
};

const readPaginatedData = (envelope: Record<string, unknown>): Record<string, unknown>[] => {
  const data = envelope.data as
    | { results?: { data?: Record<string, unknown>[] } }
    | undefined;
  return data?.results?.data ?? [];
};

const sleep = async (ms: number): Promise<void> =>
  new Promise(resolve => setTimeout(resolve, ms));

const waitForDeactivationState = async (
  harness: McpStdioHarness,
  vulnerabilityId: string,
  expectedDeactivated: boolean,
): Promise<Record<string, unknown>> => {
  for (let attempt = 0; attempt < 8; attempt += 1) {
    const current = await harness.callTool("get_vulnerability", { vulnerabilityId });
    const envelope = parseToolEnvelope(current);
    assert.equal(envelope.success, true);
    const data = readVulnerabilityData(envelope);
    const deactivateMetadata = data.deactivateMetadata;
    const isDeactivated = deactivateMetadata !== null && deactivateMetadata !== undefined;
    if (isDeactivated === expectedDeactivated) {
      return data;
    }
    await sleep(1_000);
  }

  throw new Error(
    `Timed out waiting for vulnerability ${vulnerabilityId} deactivated=${expectedDeactivated.toString()}.`,
  );
};

const discoverVulnerabilityId = async (
  harness: McpStdioHarness,
): Promise<string | null> => {
  const listed = await harness.callTool("list_vulnerabilities", {
    pageSize: 25,
    isDeactivated: false,
  });
  const listedEnvelope = parseToolEnvelope(listed);
  if (listedEnvelope.success !== true) {
    return null;
  }
  const candidate = readPaginatedData(listedEnvelope).find(
    item => typeof item.id === "string" && item.id.length > 0,
  );
  const id = candidate?.id;
  if (typeof id !== "string") {
    return null;
  }
  return id;
};

const discoverRemediationId = async (
  harness: McpStdioHarness,
  vulnerabilityId: string,
): Promise<string | null> => {
  const listed = await harness.callTool("list_vulnerability_remediations", {
    pageSize: 50,
  });
  const listedEnvelope = parseToolEnvelope(listed);
  if (listedEnvelope.success !== true) {
    return null;
  }
  const candidate = readPaginatedData(listedEnvelope).find(
    item =>
      item.vulnerabilityId === vulnerabilityId &&
      typeof item.id === "string" &&
      item.id.length > 0,
  );
  const id = candidate?.id;
  if (typeof id !== "string") {
    return null;
  }
  return id;
};

test(
  "live integration verifies vulnerability lifecycle writes with readback assertions",
  { timeout: liveEnv.timeoutMs },
  async t => {
    // Arrange
    if (!guardLiveTest(t, liveEnv, true)) {
      return;
    }
    const harness = new McpStdioHarness({ timeoutMs: liveEnv.timeoutMs });
    try {
      await startLiveWithRetry(async () => harness.start());
    } catch (error) {
      if (skipOnLiveRateLimit(t, error, "vulnerability lifecycle write")) {
        return;
      }
      throw error;
    }

    let vulnerabilityId: string | null = liveEnv.vulnerabilityId;
    let remediationId: string | null = liveEnv.remediationId;
    let needsReactivation = false;

    try {
      // Initial Assert
      const tools = await harness.listTools();
      assert.ok(tools.includes("deactivate_vulnerabilities"));
      assert.ok(tools.includes("reactivate_vulnerabilities"));
      assert.ok(tools.includes("get_vulnerability"));

      // Act
      if (!vulnerabilityId) {
        vulnerabilityId = await discoverVulnerabilityId(harness);
      }
      if (!vulnerabilityId) {
        vulnerabilityId = requireLiveFixture(
          t,
          liveEnv,
          null,
          "VANTA_INTEGRATION_TEST_VULNERABILITY_ID",
          "No active vulnerability was discovered for lifecycle testing.",
        );
        if (!vulnerabilityId) {
          return;
        }
      }

      const baseline = await harness.callTool("get_vulnerability", {
        vulnerabilityId,
      });
      const baselineEnvelope = parseToolEnvelope(baseline);
      assert.equal(baselineEnvelope.success, true);

      const deactivate = await harness.callTool("deactivate_vulnerabilities", {
        body: {
          updates: [
            {
              id: vulnerabilityId,
              deactivateReason: "Integration lifecycle verification",
              shouldReactivateWhenFixable: false,
            },
          ],
        },
        confirm: true,
      });
      const deactivateEnvelope = parseToolEnvelope(deactivate);
      assert.equal(deactivateEnvelope.success, true);
      needsReactivation = true;

      const deactivatedRead = await waitForDeactivationState(
        harness,
        vulnerabilityId,
        true,
      );
      assert.equal(typeof deactivatedRead.id, "string");

      const reactivate = await harness.callTool("reactivate_vulnerabilities", {
        body: {
          updates: [{ id: vulnerabilityId }],
        },
        confirm: true,
      });
      const reactivateEnvelope = parseToolEnvelope(reactivate);
      assert.equal(reactivateEnvelope.success, true);
      needsReactivation = false;

      const reactivatedRead = await waitForDeactivationState(
        harness,
        vulnerabilityId,
        false,
      );
      assert.equal(typeof reactivatedRead.id, "string");

      if (!remediationId) {
        remediationId = await discoverRemediationId(harness, vulnerabilityId);
      }
      if (!remediationId) {
        remediationId = requireLiveFixture(
          t,
          liveEnv,
          null,
          "VANTA_INTEGRATION_TEST_REMEDIATION_ID",
          "No vulnerability remediation was discovered for SLA acknowledgement verification.",
        );
      }
      if (!remediationId) {
        return;
      }

      const acknowledge = await harness.callTool(
        "acknowledge_sla_miss_vulnerability_remediations",
        {
          body: {
            updates: [
              {
                id: remediationId,
                slaViolationComment: "Integration test acknowledgement comment",
              },
            ],
          },
          confirm: true,
        },
      );
      const acknowledgeEnvelope = parseToolEnvelope(acknowledge);
      assert.equal(acknowledgeEnvelope.success, true);

      const remediationRead = await harness.callTool(
        "list_vulnerability_remediations",
        {
          pageSize: 50,
        },
      );
      const remediationReadEnvelope = parseToolEnvelope(remediationRead);
      assert.equal(remediationReadEnvelope.success, true);
      const acknowledged = readPaginatedData(remediationReadEnvelope).find(
        item => item.id === remediationId,
      );
      assert.ok(acknowledged);
    } finally {
      if (vulnerabilityId && needsReactivation) {
        try {
          await harness.callTool("reactivate_vulnerabilities", {
            body: {
              updates: [{ id: vulnerabilityId }],
            },
            confirm: true,
          });
        } catch {
          // Best-effort cleanup in live tenant.
        }
      }
      await harness.stop();
    }
  },
);
