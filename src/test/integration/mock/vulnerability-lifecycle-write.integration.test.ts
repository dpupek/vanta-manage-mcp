import assert from "node:assert/strict";
import test from "node:test";
import { parseToolEnvelope } from "../../helpers.js";
import { FakeVantaServer } from "./fake-vanta-server.js";
import { McpStdioHarness } from "./mcp-stdio-harness.js";

test("mock vulnerability lifecycle writes support readback verification", async () => {
  // Arrange
  const fakeServer = new FakeVantaServer();
  await fakeServer.start();
  const harness = new McpStdioHarness({
    envOverrides: {
      VANTA_API_BASE_URL: fakeServer.baseUrl,
      VANTA_CLIENT_ID: "fake-client-id",
      VANTA_CLIENT_SECRET: "fake-client-secret",
      VANTA_ENV_FILE: undefined,
    },
  });
  await harness.start();

  const vulnerability = {
    id: "vuln-1",
    name: "CVE-TEST-1",
    deactivateMetadata: null as Record<string, unknown> | null,
  };
  const remediation = {
    id: "rem-1",
    vulnerabilityId: "vuln-1",
    acknowledged: false,
  };

  fakeServer.setRoute("GET", "/vulnerabilities/vuln-1", () => ({
    status: 200,
    body: vulnerability,
  }));
  fakeServer.setRoute("POST", "/vulnerabilities/deactivate", request => {
    const body = request.jsonBody as {
      updates?: { id: string; deactivateReason?: string }[];
    };
    if (!body.updates?.some(update => update.id === "vuln-1")) {
      return { status: 400, body: { error: "missing_target" } };
    }
    vulnerability.deactivateMetadata = {
      deactivatedBy: "tester",
      deactivationReason: body.updates[0].deactivateReason ?? "reason",
    };
    return {
      status: 200,
      body: { results: [{ id: "vuln-1", status: "SUCCESS" }] },
    };
  });
  fakeServer.setRoute("POST", "/vulnerabilities/reactivate", request => {
    const body = request.jsonBody as { updates?: { id: string }[] };
    if (!body.updates?.some(update => update.id === "vuln-1")) {
      return { status: 400, body: { error: "missing_target" } };
    }
    vulnerability.deactivateMetadata = null;
    return {
      status: 200,
      body: { results: [{ id: "vuln-1", status: "SUCCESS" }] },
    };
  });
  fakeServer.setRoute("POST", "/vulnerability-remediations/acknowledge-sla-miss", request => {
    const body = request.jsonBody as {
      updates?: { id: string; slaViolationComment?: string }[];
    };
    if (!body.updates?.some(update => update.id === "rem-1")) {
      return { status: 400, body: { error: "missing_target" } };
    }
    remediation.acknowledged = true;
    return {
      status: 200,
      body: { results: [{ id: "rem-1", status: "SUCCESS" }] },
    };
  });
  fakeServer.setRoute("GET", "/vulnerability-remediations", () => ({
    status: 200,
    body: {
      results: {
        data: [remediation],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
          startCursor: null,
          endCursor: null,
        },
      },
    },
  }));

  try {
    // Initial Assert
    assert.equal(vulnerability.deactivateMetadata, null);
    assert.equal(remediation.acknowledged, false);

    // Act
    const deactivate = await harness.callTool("deactivate_vulnerabilities", {
      body: {
        updates: [
          {
            id: "vuln-1",
            deactivateReason: "Temporary exception",
            shouldReactivateWhenFixable: false,
          },
        ],
      },
      confirm: true,
    });
    const deactivateEnvelope = parseToolEnvelope(deactivate);

    const readAfterDeactivate = await harness.callTool("get_vulnerability", {
      vulnerabilityId: "vuln-1",
    });
    const readAfterDeactivateEnvelope = parseToolEnvelope(readAfterDeactivate);

    const reactivate = await harness.callTool("reactivate_vulnerabilities", {
      body: {
        updates: [{ id: "vuln-1" }],
      },
      confirm: true,
    });
    const reactivateEnvelope = parseToolEnvelope(reactivate);

    const readAfterReactivate = await harness.callTool("get_vulnerability", {
      vulnerabilityId: "vuln-1",
    });
    const readAfterReactivateEnvelope = parseToolEnvelope(readAfterReactivate);

    const acknowledge = await harness.callTool(
      "acknowledge_sla_miss_vulnerability_remediations",
      {
        body: {
          updates: [
            {
              id: "rem-1",
              slaViolationComment: "Approved by integration test",
            },
          ],
        },
        confirm: true,
      },
    );
    const acknowledgeEnvelope = parseToolEnvelope(acknowledge);

    const readRemediations = await harness.callTool(
      "list_vulnerability_remediations",
      {
        pageSize: 20,
      },
    );
    const readRemediationsEnvelope = parseToolEnvelope(readRemediations);

    // Assert
    assert.equal(deactivateEnvelope.success, true);
    assert.equal(readAfterDeactivateEnvelope.success, true);
    assert.notEqual(
      (readAfterDeactivateEnvelope.data as Record<string, unknown>)
        .deactivateMetadata,
      null,
    );
    assert.equal(reactivateEnvelope.success, true);
    assert.equal(readAfterReactivateEnvelope.success, true);
    assert.equal(
      (readAfterReactivateEnvelope.data as Record<string, unknown>)
        .deactivateMetadata,
      null,
    );
    assert.equal(acknowledgeEnvelope.success, true);
    assert.equal(readRemediationsEnvelope.success, true);
    const remediations = (
      readRemediationsEnvelope.data as { results?: { data?: Record<string, unknown>[] } }
    ).results?.data ?? [];
    const acknowledged = remediations.find(item => item.id === "rem-1");
    assert.ok(acknowledged);
    assert.equal(acknowledged.acknowledged, true);
  } finally {
    await harness.stop();
    await fakeServer.stop();
  }
});
